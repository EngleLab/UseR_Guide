# Transformations

The previous chapter covered how to use the `dplyr` functions to easily manipulate a dataframe. This chapter will cover specific transformations you might need to perform on variables in a data set. It will heavily utlize the `mutate()` function from `dplyr`.

Let's create a dataframe to use as an example for this chapter. Don't worry about what this code means for now, just copy it into your script and run it.

```{r collapse = TRUE}
data.orig <- data.frame(ID = c(1:100), Score1 = rnorm(100, mean = 2, sd = .8), Score2 = rnorm(100, mean = 7, sd = 1.1), Score3 = rnorm(100, mean = 10, sd = 1.8), Score4 = rnorm(100, mean = 20, sd = 2.3))

head(data.orig)
```


## Descriptive Statistics

Basic descriptive statistics include mean, median, standard deviation, max, min, skew, kurtosis, etc...

The functions to calculate these are pretty straightforward:

*Base R*

* __maximum__: max()

* __minimum__: min()

* __count__: n()

* __mean__: mean()

* __median__: median()

* __standard deviation__: sd()

* __variance__: var()

* __quantiles (percentiles)__: quantile()

    specify the percentiles with the argument `probs = ` (default is c(0, .25, .5, .75, 1))

*e1071* package

* __skewness__: skewness(variable, na.rm = TRUE, type = 2)

* __kurtosis__: kurtosis(variable, na.rm = TRUE, type = 2)

For all of these you need to specify `na.rm = TRUE` if the variable column has missing data. It is best to just always set `na.rm = TRUE`. For example,

```{r eval=FALSE}
mean(variable, na.rm = TRUE)
```

To calculate the overall mean on `Score1` would look like

```{r collapse = TRUE, message=FALSE, warning=FALSE}
library(dplyr)

data <- data.orig %>%
  mutate(Score1.mean = mean(Score1, na.rm = TRUE))
```

## Centering and Standardizing Variables

To standardize a variable is rather simple. Use `scale()`

```{r collapse = TRUE}
library(dplyr)

data <- data.orig %>%
  mutate(Score1.centered = scale(Score1, center = TRUE, scale = FALSE))
```

This will center scores around the mean (which just means subtacting each score by the mean).

We can check that this is true. Mean should be 0 and standard deviation should equal the original standard deviation

```{r collapse = TRUE}
round(mean(data$Score1.centered),1) == 0
sd(data$Score1) == sd(data$Score1.centered)
```

To standardize a variable (create z-scores) you can use the same `scale()` function and just specify `scale = TRUE`.

```{r collapse = TRUE}
library(dplyr)

data <- data.orig %>%
  mutate(Score1.centered = scale(Score1, center = TRUE, scale = TRUE))
```

Now the mean should be 0 and the standard deviation 1.

```{r collapse = TRUE}
round(mean(data$Score1.centered),1) == 0
round(sd(data$Score1.centered),1) == 1
```

**For an easy way to calculate centered and standardized scores on multiple variables at one time see the `center()` function from the `datawrangling` package presented in the next Chapter.**

## Transformations

### log

[insert base off of Field]

### polynomial

You can create orthogonal polynomials of variables using the `poly()` function and specify the degree of polynomial to go up to with `degree = `

```{r collapse = TRUE}
poly(data.orig$Score1, degree = 3)
```

You can see it creates up to three degrees of polynomials on the Score1 variable. The first degree is a linear, second is a quadratic, and third is cubic. Let's say we want to create three new columns with each of these three polynomials. To do so we need to individually access each vector such as

```{r collapse = TRUE}
poly(data.orig$Score1, degree = 3)[,1]
```


```{r collapse = TRUE}
library(dplyr)

data <- data.orig %>%
  mutate(Score1.linear = poly(Score1, degree = 3)[,1],
         Score1.quadratic = poly(Score1, degree = 3)[,2],
         Score1.cubic = poly(Score1, degree = 3)[,3])
```

Let's plot this to see what happened visually...

```{r collapse = TRUE}
library(ggplot2)

ggplot(data, aes(x = Score1)) +
  geom_line(aes(y = Score1.linear), color = "blue") +
  geom_line(aes(y = Score1.quadratic), color = "green") +
  geom_line(aes(y = Score1.cubic), color = "red") +
  ylab(label = "Score1.polynomial")
```

## Composites

Sometimes you will need to combine multiple variables into one. This is called a composite. Let's say we want to average the three scores in the dataframe into one `Score_comp` variable. Previosly we calculated the means in one column and across rows. Here we want to calculate means in one ROW and across columns. To do this we need a slightly different function.

To calculate row means you can use the `rowMeans()` function. This is not a tidyverse function and so we will need to specify the dataframe and columns we want. Like such

```{r collapse = TRUE}
library(dplyr)

data <- data.orig %>%
  mutate(Score_comp = rowMeans(data.orig[c("Score1", "Score2", "Score3")], na.rm = TRUE))
```

**For an easier way to create a composite variable see the `composite()` function from the `datawrangling` package presented in the next Chapter.**

## Custom Transformations

In general, with `mutate()` you can specify any custom transformation you want to do on a variable. For instance, if you want to subtract each score by `5`, and divide by `10` then you can do it! I don't know why you would ever want to do that, but you can.

```{r collapse = TRUE}
library(dplyr)

data <- data.orig %>%
  mutate(Score_crazy = (Score1 - 5)/10)
```

Or take the sum of `Score1` and `Score2` and divide by the difference between `Score3` and `Score4`.

```{r collapse = TRUE}
library(dplyr)

data <- data.orig %>%
  mutate(Score_crazy = (Score1 + Score2)/(Score3 - Score4))
```

```{r echo=FALSE, message=FALSE, warning=FALSE}
rm(list=ls())
```

********

**The next chapter covers two more important packages**