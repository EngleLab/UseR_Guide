# (PART) Create R Scripts {-}

# Create R Scripts: Overview {-}

<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.8.1/css/all.css" integrity="sha384-50oBUHEmvpQ+1lW4y57PTFmhCaXp0ML5d60M1M7uH2+nqUivzIebhndOJK28anvf" crossorigin="anonymous">

The previous section was more of a high-level overview of the organizational structure and workflow of preparing and analyzing data in R.

In this section we will dive into more of the details for actually creating R scripts at each of the stages of data preparation and analysis.

You may wish to refer back to earlier sections for more details about certain functions and working with data in R.

## Importing and Outputting Data Files {-}

If you are not familiar with coding, then you may have difficulty just importing or outputting a data file. This can become very annoying as it should be such a simple step and may discourage you a bit. Therefore, I want to go over this again. (Note I have covered this in Chapters 4 and 8).

The first thing to get a hang of is how to specify the file path and file name. There are different ways of doing this, some good and some bad.

A bad way of doing this is using what is called an **absolute** file path. The reason is that the _absolute_ file path is specific to a particular computer. No one computer is going to have the same _absolute_ file path. An _absolute_ file path starts from the root directory on your computer and may look something like:

Mac:  `~/Users/jasontsukahara/Dropbox (GaTech)/My Work/Coding Projects/R/R-Tutorial`

Windows:  `C:\Users\jasontsukahara\Dropbox (GaTech)\My Work\Coding Projects\R\R-Tutorial`

__You do not want to write scripts that can only work on a specific computer!__ One of the great advantages to programming for data processing is reproducibility. You and your future self (and other researchers) can reproduce your exact same data processing steps. __If you use absolute file paths you are undermining the reproducibility of your scripts__.

__It is good practice__ to use _relative_ file paths instead. _Relative_ file paths start from what is called a **working directory**. Let's say you have a **working directory** set to the following location:

`~/Users/jasontsukahara/Dropbox (GaTech)/My Work/Research Projects/Cool Study`

And you want to import files from a *Raw Data* directory within *Cool Study*. The absolute path to raw data files in `Cool Study` might look like: 

`~/Users/jasontsukahara/Dropbox (GaTech)/My Work/Research Projects/Cool Study/Data Files/Raw Data`

Whereas a relative file path starting from the working directory would be:

`Data Files/Raw Data`

You can see that with _relative_ file paths, only the internal organization of the project directory matters. This allows your script to be ran on different computers, systems, and environments! 

Then to import a file you would specify the file with it's relative file path using some import function:

```{r eval = FALSE}
some_import_function("Data Files/Raw Data/a_data_file.csv")
```

### Setting a working directory {-}

When you open up RStudio a working directory is automatically set. You can evaluate what the current working directory is with `getwd()`. Alternatively, you can set the current working directory with `setwd()`. 

I highly suggest not to use `setwd()` because you will have to use an absolute file path to do so. We want to avoid absolute file paths at all costs.

Fortunately, there is an elegant alternative that combines the use of .Rproj files and the `here` package.

### RProject Files and here {-}

You need to be using RProjects for your projects. There should be a single .Rproj file in each data collection and data analysis directory. I discussed RProject files in more detail in Chapter 8.

RProjects allow you to open isolated instances of R and RStudio for each of your projects. In combination with the `here` package it will also provide a simple and fool proof way of specifying file paths.

The `here` package takes a bit of explaining. 

When you load the `here` package with `library(here)`, it will start searching for a .Rproj file in the current directory the R Script is stored. If it does not find one, it will go up one directory and search there, and so on until it finds one. 

For instance, let's say in my project directory I have the following file and folders:

* ProjectName.Rproj

* R Scripts

* Data Files

If I load the `here` package in a script in the "R Scripts" folder it will look for a .Rproj file there. It will not find one and so it will go up one directory (to the projects root directory) and will find the file "ProjectName.Rproj".

**This is important** - Then it will set a file path starting at the projects root directory, where "ProjectName.Rproj" is located. *Note that it is not setting the working directory, this is an important distinction*. What it is doing is setting where a file path should start when you subsequently use the `here()` function. Therefore, you need to use `here()` function when specifying a file path and file name - `here("filepath", "filename")`.

When you load `library(here)`, it will output the starting location in the R console.

```{r echo = FALSE}
detach("package:here", unload=TRUE)
```

```{r}
library(here)
```

Now, when you use `here()` it will start at that location and you can just use a relative file path. For instance, in the project directory example above, if I run a script in the R Scripts folder that imports a data file located in "Data Files" I would specify:

```{r}
here("Data Files/a_data_file.csv")
```

Notice how the relative file path was appended to the start location set by `library(here)`. If you were to leave the argument blank inside the function then you would just get the starting location. Anything you add inside the function appends to it.

```{r}
here()
```

I like to separate out the relative file path and the file name. I think it makes my code easier to read. For instance:

```{r}
here("Data Files", "a_data_file.csv")
```

Notice how I did not have to add the "/". The `here()` function automatically adds "/" to arguments separated by commas. This way it is easy to read - on the left side you have the file path and on the right you have the file name. This is more evident when the file path is longer and involves more subfolders.

Now you would simply include this in some import and output functions:

```{r eval = FALSE}
some_import_function(here("Data Files", "a_data_file.csv"))

some_output_function(data, here("Data Files", "a_new_data_file.csv"))
```

No matter where your R script is saved (although you should have them all saved in one location) or where your working directory is set to - you can use `here()` starting at your projects root directory (as long as you have a .Rproj file saved there). 

You no longer have to think about working directories!

Unless you have a spelling error in the file path or file name, or the file does not exist - importing and outputting files should just work. Simple and easy.

```{r echo=FALSE, message=FALSE, warning=FALSE}
rm(list=ls())
```


