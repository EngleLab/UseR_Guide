# Messy to Tidy Raw Data

```{r echo=FALSE}
knitr::include_graphics(rep("images/workflow.png"))
```

This Chapter will cover the functions that will be used to convert a "messy" raw data file to a "tidy" raw data file.

I **highly** reccommend doing this for every task you use in all your studies. This will make it much easier to go back and look at raw data when you need to.

********

## What to Include

Creating a "tidy" raw data file is essentialy a process of elimination. Getting rid of columns and rows that have no value. You may also want to rename variables and values.

So what should you keep? 

You want to keep all variables (columns) that are essential to the design of the task. This might include a column that specifies the condition for each trial, a column that specifies a feature of the target stimulus, performance variables, and more. 

As for rows, I suggest keeping both practice and real trials. It is easy to filter out practice trials later. The "tidy" raw data file should contain only one row per trial per subject. 

You should probably rename variables and values to be easy for those unfamiliar with how the task was programmed to understand. Also if you have similar tasks (_Flanker_ and _Stroop_) it is probably a good idea to give similar names to variables and values. For instance, give the same name to the column that contains the condition (_congruent_, _incongruent_). Also use the same value names for each condition (not _congruent_ for one task, and _cong_ for another). Use a standard name for columns with reaction time and accuracy values (RT, Accuracy).

## Flanker Example

For this tutorial we will use an example data set from the Arrow Flanker task. If you wish to follow along using a different data set that is okay too.

You can download this example data set here 

[Download Example Flanker Data](http://englelab.gatech.edu/R/example_data/Flanker_Example.zip)

One of the files is an E-Merged file, the other is the E-Merged file exported to a tab-delimited .txt file. 

Typically, when you are doing a study there are a couple of steps you need to do in order to get these two files.

1. You need to create an E-Merged file using the E-Merge software. 

2. You need to export that E-Merged file to a .txt file. 

I have done these two steps for you already.

## Import "messy" data

The first step is importing the E-merged .txt data file. To do this use the `read_delim` function from the `readr` package. 

```{r collapse=TRUE, warning=FALSE, message=FALSE}
library(readr)
import <- read_delim("data/Flanker.txt", "\t", escape_double = FALSE, trim_ws = TRUE)
```

You can then view the data file with

```{r eval=FALSE}
View(import)
```

It is a mess, right? Here are some things you need to know about the "messy" raw data file. These are the columns and what type of values they contain:

********

**Subject**: Subject number

**Procedure[Trial]**: Procedure type (keep: TrialProc and PracTrialProc)

**PracTrialList.Sample**: Trial number for practice trials

**TrialList.Sample**: Trial number for real trials

**FlankerType**: condition for real and practice trials (Values are: congruent, incongruent)

**PracSlideTarget.RT**: Reaction time for practice trials

**PracSlideTarget.ACC**: Accuracy for practice trials

**PracSlideTarget.RESP**: Response for practice trials ({LEFTARROW} = left and {RIGHTARROW} = right)

**SlideTarget.RT**: Reaction time for real trials

**SlideTarget.ACC**: Accuracy for real trials

**SlideTarget.RESP**: Response for real trials ({LEFTARROW} = left and {RIGHTARROW} = right)

**TargerDirection**: direction of the target arrow for practice trials

**TargetDirection**: direction of the target arrow for real trials

**SessionDate**: Date of session

**SessionTime**: Time of session

********

### Remove Duplicate Subjects

Now it happens on occasion that the wrong subject number is entered in when an RA is starting up a task. This can result in duplicate Subject numbers in the E-Merge file. Luckily I have created a function to remove the duplicate subjects, and put their information (with session date and time) into a specific file. This file will be created in a new folder called "duplicates".

The function is `duplicates.remove()` from the `datawrangling` package on my GitHub.

It can be difficult to remember what arguments you need to include in a function. To see helpful documentation about a function you can type in the console

```{r eval=FALSE}
library(datawrangling)
?duplicates.remove
```


```{r warning=FALSE, collapse=TRUE, message=FALSE}
library(readr)
library(datawrangling)

import <- read_delim("data/Flanker.txt", "\t", escape_double = FALSE, trim_ws = TRUE)
import <- duplicates.remove(import, taskname = "Flanker", output.folder = "data/duplicates")
```

## "Tidy" Up

### Filter

https://dplyr.tidyverse.org/reference/filter.html

Filter only relevant rows. We want to keep only the rows that contain trials from the practice and real trials. To do this we use the `filter()` function of the `dplyr` package. 

```{r warning=FALSE, collapse=TRUE, message=FALSE}
library(dplyr)
data_flanker <- import %>%
  filter(`Procedure[Trial]`=="TrialProc" | `Procedure[Trial]`=="PracTrialProc")
```

The first argrument is the dataframe that should be passed to the function, in this case `import`. The second argument specifies what kind of filter we want to apply. We are stating that we want to include only rows in which ``Procedure[Trial]`` equals `"TrialProc"` or `|` ``Procedure[Trial]`` equals `"PracTrialProc"`. These are the rows that contain practice and real trials.

You are allowed to specify as many filter arguments as you like (seperated by commas). When filter arguments are seperated by commas instead of `|`, then this amounts to the statement `AND` rather than `OR`.

Also the column names are contained in single quotes because the names contain the special characters `[ ]`. There are certain characters R does not like to use as variable names and one of them is square brackets.

### Rename

Now the column specifying real vs practice trials is a little tedious to keep typing out since it requires the single quotes and brackets. We will also want to rename this column to be more coherent in the final "tidy" data format anyways. To rename columns we can use `rename()` function in `dplyr`.

```{r warning=FALSE, collapse=TRUE, message=FALSE}
library(dplyr)
data_flanker <- import %>%
  filter(`Procedure[Trial]`=="TrialProc" | `Procedure[Trial]`=="PracTrialProc") %>%
  rename(TrialProc = `Procedure[Trial]`)
```

### Mutate

https://dplyr.tidyverse.org/reference/mutate.html

We will use `mutate()` to clean up the "messy" raw data file.

First let's change the values in `TrialProc`. Right now real trials have the value of "TrialProc". The same name as the column, not good! And the "practice" trials have the value of "PractTrialProc". Let's simply change these values to "real" and "practice", respectively. 

```{r collapse=TRUE, message=FALSE, warning=FALSE}
library(dplyr)
data_flanker <- import %>%
  filter(`Procedure[Trial]`=="TrialProc" | `Procedure[Trial]`=="PracTrialProc") %>%
  rename(TrialProc = `Procedure[Trial]`) %>%
  mutate(TrialProc = ifelse(TrialProc=="TrialProc", "real", "practice"))
```

So the `TrialProc` gets set to either "real" or "practice" depending on whether the current value is equal to "TrialProc" or not.

Note that we are not being very specific with `ifelse()`. Rows that do not equal `"TrialProc"` get set as `"practice"`. This is okay ONLY because we already applied a filter to only include rows with the value `"TrialProc"` or with the value `"PracTrialProc"`. If we did not apply this filter, or if there were more than two values for the column `TrialProc`, then we rows that were not `"PracTrialProc"` will get set to `"practice"`. 

The point is, be careful how you are using `ifelse()`.

********

Okay now let's move on to figuring out what other columns we want to keep and if we need to do any more computations on them.

We want to keep the columns that specify the following information

* Subject number
* TrialProc (real vs practice)
* Trial number 
* Condition (congruent vs incongruent)
* Reaction time
* Accuracy
* Response
* Target arrow direction (left or right)
* Session Date
* Session Time

This gets a little more tricky here because the information for some of these variables are in one column for practice trials and a different column for real trials. That means we need to merge the information from these two columns into one. We can do this using the`mutate()` function from the `dplyr` package.

```{r collapse=TRUE, message=FALSE, warning=FALSE}
library(dplyr)
data_flanker <- import %>%
  filter(`Procedure[Trial]`=="TrialProc" | `Procedure[Trial]`=="PracTrialProc") %>%
  rename(TrialProc = `Procedure[Trial]`) %>%
  mutate(TrialProc = ifelse(TrialProc=="TrialProc", "real", "practice"),
         RT = ifelse(TrialProc=="real", SlideTarget.RT, PracSlideTarget.RT))
```

So the new column RT gets set to the value that is contained in SlideTarget.RT if it is a real trial, if not then the RT gets a value contained in PracSlideTarget.RT

We can do the same thing for trial, accuracy, response, and target arrow direction. Combining them all into one `mutate()` function

```{r collapse=TRUE, message=FALSE, warning=FALSE}
library(dplyr)
data_flanker <- import %>%
  filter(`Procedure[Trial]`=="TrialProc" | `Procedure[Trial]`=="PracTrialProc") %>%
  rename(TrialProc = `Procedure[Trial]`) %>%
  mutate(TrialProc = ifelse(TrialProc=="TrialProc", "real", "practice"),
         RT = ifelse(TrialProc=="real", SlideTarget.RT, PracSlideTarget.RT),
         ACC = ifelse(TrialProc=="real", SlideTarget.ACC, PracSlideTarget.ACC),
         Response = ifelse(TrialProc=="real", SlideTarget.RESP, PracSlideTarget.RESP),
         TargetArrowDirection = ifelse(TrialProc=="real", TargetDirection, TargerDirection))
```

You might want to change the values in the Response and CorrectResponse columns to be more clear (left and right).

```{r collapse=TRUE, message=FALSE, warning=FALSE}
library(dplyr)
data_flanker <- import %>%
  filter(`Procedure[Trial]`=="TrialProc" | `Procedure[Trial]`=="PracTrialProc") %>%
  rename(TrialProc = `Procedure[Trial]`) %>%
  mutate(TrialProc = ifelse(TrialProc=="TrialProc", "real", "practice"),
         RT = ifelse(TrialProc=="real", SlideTarget.RT, PracSlideTarget.RT),
         ACC = ifelse(TrialProc=="real", SlideTarget.ACC, PracSlideTarget.ACC),
         Response = ifelse(TrialProc=="real", SlideTarget.RESP, PracSlideTarget.RESP),
         TargetArrowDirection = ifelse(TrialProc=="real", TargetDirection, TargerDirection),
         Response = ifelse(Response=="{LEFTARROW}", "left", ifelse(Response=="{RIGHTARROW}", "right", NA)))
```

Notice how I included an `ifelse()` function inside of an `ifelse()` function. The inner `ifelse()` will occur if `Response` does not equal `"{LEFTARROW}"`. 

You have to be careful with `ifelse()` statements because sometimes it does something you do not expect it to. **That is why it is always important to check to make sure your code is performing as you want it to.** View the dataframe to make sure everything is good. The new columns will be added at the end of the dataframe.

### Select

https://dplyr.tidyverse.org/reference/select.html

We are getting closer to a "tidy" raw data file. The only thing left is to select only the columns we want to keep. We do this by using the `select()` function from the `dplyr` package.

Remember we want to only select columns with the following information

* Subject number
* Trial number 
* Condition
* Reaction time
* Accuracy
* Response
* Correct Response
* Target arrow direction
* Session Date
* Session Time

```{r collapse=TRUE, message=FALSE, warning=FALSE}
library(dplyr)
data_flanker <- import %>%
  filter(`Procedure[Trial]`=="TrialProc" | `Procedure[Trial]`=="PracTrialProc") %>%
  rename(TrialProc = `Procedure[Trial]`) %>%
  mutate(TrialProc = ifelse(TrialProc=="TrialProc", "real", "practice"),
         RT = ifelse(TrialProc=="real", SlideTarget.RT, PracSlideTarget.RT),
         ACC = ifelse(TrialProc=="real", SlideTarget.ACC, PracSlideTarget.ACC),
         Response = ifelse(TrialProc=="real", SlideTarget.RESP, PracSlideTarget.RESP),
         TargetArrowDirection = ifelse(TrialProc=="real", TargetDirection, TargerDirection),
         Response = ifelse(Response=="{LEFTARROW}", "left", ifelse(Response=="{RIGHTARROW}", "right", NA))) %>%
  select(Subject, TrialProc, Trial, Condition = FlankerType, RT, ACC, Response, TargetArrowDirection)
```

## Save to File

The function of an R script is to import a dataframe -> transform or analyze the dataframe -> output a final product (a new dataframe or analysis output). The objects which an R script creates (which you can see in the **Environemnt** window) are not the final end point. These are just temporary objects that are used to go from an input -> output. 

You have done the importing and transforming; now you need to output the final product - which is a saved .txt file of the "tidy" raw data.

To save the dataframe to a .txt file you will use the `write_delim()` function of the `readr` package.

```{r collapse=TRUE, message=FALSE, warning=FALSE, eval = FALSE}
write_delim(data_flanker, path = "data/Flanker_raw.txt", delim = "\t", na = "")
```

********

Then if we were to put it all together, using the template from the previous chapter:

```{r eval = FALSE}
## Set up ####
## Load required packages
library(here)
library(readr)
library(dplyr)
library(datawrangling)

## Set import and output directories
import.dir <- "data/"
output.dir <- "data/"
##############

## Import data
import <- read_delim(here(import.dir, "Flanker.txt"), "\t", escape_double = FALSE, trim_ws = TRUE) %>%
  duplicates.remove(taskname = "Flanker", output.folder = "data/duplicates")

## Tidy 
data_flanker <- import %>%
  filter(`Procedure[Trial]`=="TrialProc" | `Procedure[Trial]`=="PracTrialProc") %>%
  rename(TrialProc = `Procedure[Trial]`) %>%
  mutate(TrialProc = ifelse(TrialProc=="TrialProc", "real", "practice"),
         RT = ifelse(TrialProc=="real", SlideTarget.RT, PracSlideTarget.RT),
         ACC = ifelse(TrialProc=="real", SlideTarget.ACC, PracSlideTarget.ACC),
         Response = ifelse(TrialProc=="real", SlideTarget.RESP, PracSlideTarget.RESP),
         TargetArrowDirection = ifelse(TrialProc=="real", TargetDirection, TargerDirection),
         Response = ifelse(Response=="{LEFTARROW}", "left", ifelse(Response=="{RIGHTARROW}", "right", NA))) %>%
  select(Subject, TrialProc, Trial, Condition = FlankerType, RT, ACC, Response, TargetArrowDirection)

## Save Data
write_delim(data_flanker, path = here(output.dir, "Flanker_raw.txt"), delim = "\t", na = "")

rm(list=ls())
```


********

## Binding Individual Subject Files

Now I want to go over how bind individual subject files into one file.

The `subj` folder contains individual files for each subject. You will use these files to learn how to bind multiple subject files into one file. In E-Prime you can use the E-Merge software to bind individual subject .edat2 files, so this is actually not always necessary. 

However, you may have a task running in a different program othan E-Prime. Also, in E-Prime 3.0 there is the option to save the .edat2 file as a .txt file. **This can allow you to bypass using E-Merge and simply create an R script to bind all the .txt files)**. I have created individual subject files in the `subj` folder for the sake of this tutorial. 

You can "bind" either the rows or columns of a dataframe together. A column "bind" means the dataframes have different column (same rows) and you are simply binding the columns together. A row "bind" means the dataframes have different rows (same columns) and you are simply binding the rows of the dataframes ontop of one another.

For our purspose here, what we want to do is a row "bind". Since each subject has the same columns but different rows. We basically want to stack the files ontop of each other.

This requires several steps and the use of a for loop. Luckily, I created a function to do this for us so it will be very simple! 

The function we will use is `files.bindr()` from my `datawrangling` package.

Remember you can use `?files.bind` to see documentation about how to use a function

```{r eval=FALSE}
devtools::install_github("dr-JT/datawrangling")
library(datawrangling)
data_merged <- files.bind(path = "data/subj", pattern = "_Flanker.txt", delim = "\t", na = "", bind = "rows", output.file = "data/Flanker_merged.txt")
```

There are a few arguments you need to specify. 

`path` specifies the folder in which all the files are located. 

`pattern` is a certain patter of letters that every file has in common. If there are other files in the same folder you want to make sure this pattern is unique to only the files you want to merge. 

`delim` specifies both the delimiter that the individual files have and what the final merged file should have. 

`na` is how missing values should be specified. 

`bind` what type of bind do you wan to perform. "rows" or "columns" or "cols".

`output.file` is the file path and name to save the merged file to.

Here is the function for `files.bind()`. You can let me know if you have any questions about this.

```{r eval=FALSE}
files.bind <- function(path = "", pattern = "", delim = "\t", na = "", output.file = "", bind = "rows"){
  filelist <- list.files(path = path, pattern = pattern, full.names = TRUE)
  import <- list()
  for (i in seq_along(filelist)){
    import[[i]] <- readr::read_delim(filelist[[i]], delim, escape_double = FALSE, trim_ws = TRUE, na = na)
  }

  if (bind=="rows"){
    bound <- dplyr::bind_rows(import)
  }
  if (bind=="columns"|bind=="cols"){
    bound <- dplyr::bind_cols(import)
  }


  if (output.file!=""){
    readr::write_delim(bound, path = output.file, delim, na = na)
  }
  return(bound)
}
```

```{r echo=FALSE, message=FALSE, warning=FALSE}
rm(list=ls())
```

********

**Now on to scoring the "tidy" raw data file**

